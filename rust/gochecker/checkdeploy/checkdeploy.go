package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
)

func main() {
	dirPath := flag.String("dir", "./target/deploy", "Directory containing the generated .sh files")
	programName := flag.String("program", "", "Program name for the .so and program ID files (required)")
	ownerPath := flag.String("owner", "~/.config/solana/id.json", "Path to the owner keypair")
	flag.Parse()

	if *programName == "" {
		log.Fatalf("Program name is required. Please provide a valid program name using the --program flag.")
	}

	soFilePath := fmt.Sprintf("%s.so", *programName)
	programIDPath := fmt.Sprintf("%s-keypair.json", *programName)

	soFileSize, err := getFileSize(filepath.Join(*dirPath, soFilePath))
	if err != nil {
		log.Fatalf("Error getting size of .so file: %v\n", err)
	}

	maxLen := soFileSize * 3 / 2

	generateDeployScript(*dirPath, soFilePath, programIDPath, *ownerPath, maxLen, *programName)
	generateRecoverDeployScript(*dirPath, *ownerPath, maxLen, *programName)
}

func getFileSize(filePath string) (int64, error) {
	fileInfo, err := os.Stat(filePath)
	if err != nil {
		return 0, err
	}
	return fileInfo.Size(), nil
}

func generateDeployScript(dirPath, soFilePath, programIDPath, ownerPath string, maxLen int64, programName string) {
	scriptPath := filepath.Join(dirPath, fmt.Sprintf("deploy_%s.sh", programName))

	// Check if the file already exists and add write permissions if needed
	if _, err := os.Stat(scriptPath); err == nil {
		// File exists, add write permission
		err = os.Chmod(scriptPath, 0755)
		if err != nil {
			log.Fatalf("Error adding write permissions for %s: %v\n", scriptPath, err)
		}
	}

	scriptContent := fmt.Sprintf(`#!/bin/bash

# Do not edit this file manually. This file is automatically generated by the init.sh script.

# Prompt for the program name
read -p "Please enter the program name: " program_name

if [ -z "$program_name" ];then
  echo "Program name is required. Exiting..."
  exit 1
fi

# Validate program name
if [ "$program_name" != "%s" ]; then
  echo "Error: Program name does not match the expected name '%s'. Exiting..."
  exit 1
fi

# Proceed with the program deployment
solana program deploy %s --program-id %s --upgrade-authority %s --keypair %s --max-len %d

echo "Deployment complete for program name: $program_name"
`, programName, programName, soFilePath, programIDPath, ownerPath, ownerPath, maxLen)

	err := os.WriteFile(scriptPath, []byte(scriptContent), 0755)
	if err != nil {
		log.Fatalf("Error writing %s script: %v\n", scriptPath, err)
	}

	// Set the file to read-only after writing
	err = os.Chmod(scriptPath, 0555)
	if err != nil {
		log.Fatalf("Error setting read-only permissions for %s: %v\n", scriptPath, err)
	}

	fmt.Printf("deploy_%s.sh script generated successfully at %s and set to read-only.\n", programName, scriptPath)
}

func generateRecoverDeployScript(dirPath, ownerPath string, maxLen int64, programName string) {
	scriptPath := filepath.Join(dirPath, fmt.Sprintf("recover_deploy_%s.sh", programName))

	// Check if the file already exists and add write permissions if needed
	if _, err := os.Stat(scriptPath); err == nil {
		// File exists, add write permission
		err = os.Chmod(scriptPath, 0755)
		if err != nil {
			log.Fatalf("Error adding write permissions for %s: %v\n", scriptPath, err)
		}
	}

	scriptContent := fmt.Sprintf(`#!/bin/bash

# Do not edit this file manually. This file is automatically generated by the init.sh script.

# Prompt for the program name
read -p "Please enter the program name: " program_name

if [ -z "$program_name" ];then
  echo "Program name is required. Exiting..."
  exit 1
fi

# Validate program name
if [ "$program_name" != "%s" ]; then
  echo "Error: Program name does not match the expected name '%s'. Exiting..."
  exit 1
fi

# Prompt for the seed phrase
read -p "[recover] seed phrase: " recover_phrase

if [ -z "$recover_phrase" ];then
  echo "Seed phrase is required. Exiting..."
  exit 1
fi

# Replace spaces with underscores in the seed phrase and append .json suffix
recover_json=$(echo ".%s_recover_"$recover_phrase | tr ' ' '_').json

# Check if the file already exists
if [ ! -f "$recover_json" ]; then
  # Use solana-keygen to recover the keypair
  solana-keygen recover -o "$recover_json"

  # Check if the recovery was successful
  if [ ! -f "$recover_json" ]; then
    echo "Error: Recovery failed. You might have forgotten to confirm by typing 'y'. Please try again."
    exit 1
  else
    echo "Keypair recovered and saved to $recover_json"
  fi
fi

# Proceed with the recovery deployment
solana program deploy --max-len %d --buffer "$recover_json" --program-id %s-keypair.json --upgrade-authority %s %s.so

echo "Recovery deployment complete for program name: $program_name, with recovery JSON: $recover_json"
`, programName, programName, programName, maxLen, programName, ownerPath, programName)

	err := os.WriteFile(scriptPath, []byte(scriptContent), 0755)
	if err != nil {
		log.Fatalf("Error writing %s script: %v\n", scriptPath, err)
	}

	// Set the file to read-only after writing
	err = os.Chmod(scriptPath, 0555)
	if err != nil {
		log.Fatalf("Error setting read-only permissions for %s: %v\n", scriptPath, err)
	}

	fmt.Printf("recover_deploy_%s.sh script generated successfully at %s and set to read-only.\n", programName, scriptPath)
}
